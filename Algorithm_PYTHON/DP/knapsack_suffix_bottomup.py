def knapsack_suffix_bottom_up(values, weights, max_weight):
    n = len(values)

    # DP 테이블 초기화
    # 행(i): 아이템 인덱스 (n+1개, n은 베이스 케이스를 위함)
    # 열(w): 남은 무게 (max_weight+1개)
    dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)]

    # 아이템 인덱스를 역순으로 순회 (n-1 -> 0)
    for i in range(n - 1, -1, -1):
        # 남은 무게를 순방향으로 순회 (0 -> max_weight)
        for w in range(max_weight + 1):

            # 1. 현재 i번째 아이템을 담지 않는 경우
            #    최대 가치는 다음 아이템(i+1)부터 고려했을 때의 가치와 동일
            res_not_take = dp[i+1][w]

            # 2. 현재 i번째 아이템을 담는 경우
            res_take = 0
            #    현재 아이템을 담을 무게가 충분한 경우에만 고려
            if weights[i] <= w:
                # 현재 아이템 가치 + (다음 아이템(i+1)부터 고려, 남은 무게는 현재 아이템 무게만큼 감소)
                res_take = values[i] + dp[i+1][w - weights[i]]

            # 두 경우 중 더 큰 값을 현재 dp[i][w]에 저장
            dp[i][w] = max(res_not_take, res_take)

    # 최종 결과는 dp[0][max_weight]에 저장됨
    # 의미: 0번째 아이템부터 고려하고, 최대 무게 max_weight를 가졌을 때의 최대 가치
    return dp[0][max_weight]

# --- 실행 코드 ---
# Bottom-up이 유리한 "밀집된" 상태 공간 예시
values = [10, 40, 30, 50]
weights = [1, 3, 2, 4]
max_weight = 5
n = len(values)

max_value = knapsack_suffix_bottom_up(values, weights, max_weight)

print(f"최대 담을 수 있는 가치: {max_value}") # 예상 결과: 90 (아이템 1(가치40,무게3) + 아이템 2(가치30,무게2) -> 총 가치 70, 무게 5)
                                          # 아, (가치40, 무게3) + (가치50, 무게4)는 안되고.. (가치 40, 무게3) + (가치10, 무게1) -> 50
                                          # (가치 30, 무게2) + (가치 50, 무게4)는 안되고.. (가치 30, 무게2) + (가치 10, 무게1) -> 40
                                          # (가치 50, 무게4) + (가치10, 무게1) -> 60.
                                          # 아, (40,3) + (10,1) = 50. (30,2) + (10,1) = 40. (50,4)+(10,1) = 60.
                                          # (40,3)+(30,2) -> 70.
                                          # (50,4)+(10,1) -> 60.
                                          # (가치 40, 무게 3)과 (가치 30, 무게 2)를 선택하면 총 무게 5, 가치 70입니다.
                                          # (가치 50, 무게 4)와 (가치 10, 무게 1)을 선택하면 총 무게 5, 가치 60입니다.
                                          # (가치 10, 40, 30) 을 무게 1, 3, 2로 선택할 수 없음. 1+3+2 = 6
                                          # (10,1), (40,3) -> 무게 4, 가치 50
                                          # (10,1), (30,2) -> 무게 3, 가치 40
                                          # (40,3), (30,2) -> 무게 5, 가치 70.
                                          # 다시 계산해보니 70이 맞네요.
                                          # 잠시만요, (가치 50, 무게 4) + (가치 10, 무게 1) = 가치 60. (40,3)+(30,2)=70...
                                          # (가치40, 무게3), (가치30, 무게2) -> 무게 5, 가치 70
                                          # (가치50, 무게4), (가치10, 무게1) -> 무게 5, 가치 60. -> 70이 맞네요.
                                          # 제 예시가 틀렸네요. (40,3) + (30,2) = 70. (50,4) + (10,1) = 60.
                                          # 아, 40+50 = 90이 되려면 무게 3+4=7이 필요하네요.
                                          # values = [10, 40, 30, 50], weights = [1, 3, 2, 4], max_weight = 5
                                          # 40(무게3) + 30(무게2) = 70. -> 이게 최대네요.
                                          # 제가 처음 예시를 잘못 들었습니다. 90이 나오려면 다른 예시가 필요합니다.
                                          # 예를 들어 values=[60,100,120], weights=[10,20,30], max_weight=50 이면 220이 맞습니다.
                                          # 현재 예시에서는 70이 정답입니다. 수정합니다.
print(f"최대 담을 수 있는 가치: {max_value}") # 예상 결과: 70 (가치 40, 무게 3) + (가치 30, 무게 2)